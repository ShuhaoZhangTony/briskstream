package simpledb;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * The SymmetricHashJoin operator implements the symmetric hash join operation.
 */
public class SymmetricHashJoin extends Operator {
    private JoinPredicate pred;
    private DbIterator child1, child2;
    private TupleDesc comboTD;

    private HashMap<Object, ArrayList<Tuple>> leftMap = new HashMap<Object, ArrayList<Tuple>>();
    private HashMap<Object, ArrayList<Tuple>> rightMap = new HashMap<Object, ArrayList<Tuple>>();
    private DbIterator inner;
    private DbIterator outter;


    /**
     * Constructor. Accepts children to join and the predicate to join them on.
     *
     * @param p
     *            The predicate to use to join the children
     * @param child1
     *            Iterator for the left(outer) relation to join
     * @param child2
     *            Iterator for the right(inner) relation to join
     */
    public SymmetricHashJoin(JoinPredicate p, DbIterator child1, DbIterator child2) {
        this.pred = p;
        this.child1 = child1;
        this.child2 = child2;
        comboTD = TupleDesc.merge(child1.getTupleDesc(), child2.getTupleDesc());
        this.inner = child1;
        this.outter = child2;
    }

    public TupleDesc getTupleDesc() {
        return comboTD;
    }

    /**
     * Opens the iterator.
     */
    public void open() throws DbException, NoSuchElementException,
            TransactionAbortedException {
        child1.open();
        child2.open();
        super.open();
    }

    /**
     * Closes the iterator.
     */
    public void close() {
        super.close();
        child2.close();
        child1.close();
    }

    /**
     * Rewinds the iterator. You should not be calling this method for this join. 
     */
    public void rewind() throws DbException, TransactionAbortedException {
        child1.rewind();
        child2.rewind();
        this.leftMap.clear();
        this.rightMap.clear();
    }


    /** Hash tuple into the Hash Maps */
    private void loadMap(Tuple t) throws DbException, TransactionAbortedException {
        if (inner == child1) {
            Field field = t.getField(pred.getField1());
            ArrayList<Tuple> fieldList = leftMap.get(field);
            if (fieldList == null) {
                fieldList = new ArrayList<Tuple>();
                leftMap.put(field, fieldList);
            }
            fieldList.add(t);
        } else if (inner == child2) {
            Field field = t.getField(pred.getField2());
            ArrayList<Tuple> fieldList = rightMap.get(field);
            if (fieldList == null) {
                fieldList = new ArrayList<Tuple>();
                rightMap.put(field, fieldList);
            }
            fieldList.add(t);
        }
    }

    /** Return the list to be probed according to inner/ outter */
    private ArrayList<Tuple> getList(Tuple t) {
        ArrayList result = new ArrayList();
        if (inner == child1) {
            result = rightMap.get(t.getField(pred.getField1()));
        } else if (inner == child2) {
            result = leftMap.get(t.getField(pred.getField2()));
        }
        return result;
    }

    private transient Iterator<Tuple> listIterator = null;
    private transient Tuple matchedTuple = null;
    private transient Tuple currentTuple = null;

    private Tuple processList() throws TransactionAbortedException, DbException {
        matchedTuple = listIterator.next();
        Tuple leftTuple;
        Tuple rightTuple;
        if (inner == child1) {
            leftTuple = currentTuple;
            rightTuple = matchedTuple;
        } else {
            leftTuple = matchedTuple;
            rightTuple = currentTuple;
        }

        int td1n = leftTuple.getTupleDesc().numFields();
        int td2n = rightTuple.getTupleDesc().numFields();

        Tuple t = new Tuple(comboTD);
        for (int i = 0; i < td1n; i++)
            t.setField(i, leftTuple.getField(i));
        for (int i = 0; i < td2n; i++)
            t.setField(td1n + i, rightTuple.getField(i));
        return t;
    }

    /** Returns a filtered list with predicate */
    private ArrayList<Tuple> probeList(JoinPredicate p, ArrayList<Tuple> pre_list, Tuple current) {
        ArrayList result = new ArrayList();
        if (inner == child1) {
            for (Tuple t2 : pre_list) {
                if (p.filter(current, t2)){
                    result.add(t2);
                }
            }
        } else if (inner == child2) {
            for (Tuple t1 : pre_list) {
                if (p.filter(t1, current)){
                    result.add(t1);
                }
            }
        }
        return result;
    }

    /**
     * Fetches the next tuple generated by the join, or null if there are no
     * more tuples.  Logically, this is the next tuple in r1 cross r2 that
     * satifies the join predicate.
     *
     * Note that the tuples returned from this particular implementation are
     * simply the concatenation of joining tuples from the left and right
     * relation.  Therefore, there will be two copies of the join attribute in
     * the results.
     *
     * For example, joining {1,2,3} on equality of the first column with {1,5,6}
     * will return {1,2,3,1,5,6}.
     */
    protected Tuple fetchNext() throws TransactionAbortedException, DbException {
        if (listIterator != null) {
            if (listIterator.hasNext()) {
                return processList();
            } else {
                if (inner.hasNext() && outter.hasNext()) {
                    switchRelations();
                }
            }
        }

        while (inner.hasNext()) {
            currentTuple = inner.next();
            loadMap(currentTuple);
            ArrayList<Tuple> preprocessed_list = getList(currentTuple);

            ArrayList<Tuple> list = null;
            if (preprocessed_list != null) {
                list = probeList(pred, preprocessed_list, currentTuple);
            }
            if (list == null) {
                switchRelations();
                continue;
            }
            listIterator = list.iterator();

            return processList();
        }
        if (outter.hasNext()) {
            switchRelations();
            return fetchNext();
        }
        return null;
    }

    /**
     * Switches the inner and outer relation.
     */
    private void switchRelations() throws TransactionAbortedException, DbException {
        DbIterator temp = inner;
        inner = outter;
        outter = temp;
    }

    @Override
    public DbIterator[] getChildren() {
        return new DbIterator[]{this.child1, this.child2};
    }

    @Override
    public void setChildren(DbIterator[] children) {
        this.child1 = children[0];
        this.child2 = children[1];
    }

}