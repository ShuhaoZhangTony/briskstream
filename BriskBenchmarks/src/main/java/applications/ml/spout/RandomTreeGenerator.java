package applications.ml.spout;

import applications.ml.datatypes.Attribute;
import applications.ml.datatypes.DenseInstance;
import applications.ml.datatypes.instance.Instance;
import applications.ml.datatypes.instance.Instances;
import applications.ml.datatypes.instance.InstancesHeader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Random;


/**
 * Generates a stream based on a randomly generated tree.
 * It constructs a decision tree by splitting a chosen feature randomly, and assigning a random class label to each leaf.
 * Once the tree is built, new examples are generated by assigning uniformly distributed random values to features which then determine the class label via the tree.
 * http://huawei-noah.github.io/streamDM/docs/generators.html
 */

public class RandomTreeGenerator {
    private static final Logger LOG = LoggerFactory.getLogger(RandomTreeGenerator.class);

    // options for instance

    private int numValsPerNominalOption = 5;//The number of values to generate per nominal attribute. range 2~max

    private int numNominalsOption = 5;//The number of nominal attributes to generate. range 0~max.

    private int numNumericsOption = 5; //"The number of numeric attributes to generate." range 0~max.

    private int numClassesOption = 2; //"The number of classes to generate." range 2~max.

    private InstancesHeader streamHeader;

    private int instanceRandomSeedOption = 1;//"Seed for random generation of instances."

    protected Random instanceRandom;

    // options for tree

    private int treeRandomSeedOption = 1;//Seed for random generation of tree.

    private int firstLeafLevelOption = 3;//The first level of the tree above maxTreeDepth that can have leaves. range 0~max


    protected Node treeRoot;

    private int maxTreeDepthOption = 5;//The maximum depth of the tree concept. range 0~max.

    private double leafFractionOption = 0.15;//"The fraction of leaves per level from firstLeafLevel onwards." range 0~1.0


    public RandomTreeGenerator(int thisTaskId, int numContestants) {

    }

    public Instance nextInstance() {
        double[] attVals = new double[this.numNominalsOption
                + this.numNumericsOption];
        InstancesHeader header = getHeader();
        Instance inst = new DenseInstance(header.numAttributes());
        for (int i = 0; i < attVals.length; i++) {
            attVals[i] = i < this.numNominalsOption ? this.instanceRandom.nextInt(this.numValsPerNominalOption)
                    : this.instanceRandom.nextDouble();
            inst.setValue(i, attVals[i]);
        }
        inst.setDataset(header);
        inst.setClassValue(classifyInstance(this.treeRoot, attVals));
        return inst;
    }

    protected int classifyInstance(Node node, double[] attVals) {
        if (node.children == null) {
            return node.classLabel;
        }
        if (node.splitAttIndex < this.numNominalsOption) {
            return classifyInstance(
                    node.children[(int) attVals[node.splitAttIndex]], attVals);
        }
        return classifyInstance(
                node.children[attVals[node.splitAttIndex] < node.splitAttValue ? 0
                        : 1], attVals);
    }

    public InstancesHeader getHeader() {
        return this.streamHeader;
    }


    protected static class Node implements Serializable {

        private static final long serialVersionUID = 1L;

        public int classLabel;

        public int splitAttIndex;

        public double splitAttValue;

        public Node[] children;
    }

    private void generateHeader() {
        ArrayList<Attribute> attributes = new ArrayList<>();
        ArrayList<String> nominalAttVals = new ArrayList<>();
        for (int i = 0; i < this.numValsPerNominalOption; i++) {
            nominalAttVals.add("value" + (i + 1));
        }
        for (int i = 0; i < this.numNominalsOption; i++) {
            attributes.add(new Attribute("nominal" + (i + 1), nominalAttVals));
        }
        for (int i = 0; i < this.numNumericsOption; i++) {
            attributes.add(new Attribute("numeric" + (i + 1)));
        }
        ArrayList<String> classLabels = new ArrayList<>();
        for (int i = 0; i < this.numClassesOption; i++) {
            classLabels.add("class" + (i + 1));
        }
        attributes.add(new Attribute("class", classLabels));

//        this.streamHeader = new InstancesHeader(new Instances(getCLICreationString(InstanceStream.class), attributes, 0));
        this.streamHeader = new InstancesHeader(new Instances("RandomTreeGenerator", attributes, 0));

        this.streamHeader.setClassIndex(this.streamHeader.numAttributes() - 1);
    }

    private void generateRandomTree() {

        Random treeRand = new Random(this.treeRandomSeedOption);

        ArrayList<Integer> nominalAttCandidates = new ArrayList<>(this.numNominalsOption);

        for (int i = 0; i < this.numNominalsOption; i++) {
            nominalAttCandidates.add(i);
        }
        double[] minNumericVals = new double[this.numNumericsOption];
        double[] maxNumericVals = new double[this.numNumericsOption];
        for (int i = 0; i < this.numNumericsOption; i++) {
            minNumericVals[i] = 0.0;
            maxNumericVals[i] = 1.0;
        }
        this.treeRoot = generateRandomTreeNode(0, nominalAttCandidates,
                minNumericVals, maxNumericVals, treeRand);
    }

    protected Node generateRandomTreeNode(int currentDepth,
                                          ArrayList<Integer> nominalAttCandidates, double[] minNumericVals,
                                          double[] maxNumericVals, Random treeRand) {
        if ((currentDepth >= this.maxTreeDepthOption)
                || ((currentDepth >= this.firstLeafLevelOption)
                && (this.leafFractionOption >= (1.0 - treeRand.nextDouble())))) {
            Node leaf = new Node();
            leaf.classLabel = treeRand.nextInt(this.numClassesOption);
            return leaf;
        }
        Node node = new Node();
        int chosenAtt = treeRand.nextInt(nominalAttCandidates.size()
                + this.numNumericsOption);
        if (chosenAtt < nominalAttCandidates.size()) {
            node.splitAttIndex = nominalAttCandidates.get(chosenAtt);
            node.children = new Node[this.numValsPerNominalOption];
            ArrayList<Integer> newNominalCandidates = new ArrayList<>(
                    nominalAttCandidates);
            newNominalCandidates.remove(new Integer(node.splitAttIndex));
            newNominalCandidates.trimToSize();
            for (int i = 0; i < node.children.length; i++) {
                node.children[i] = generateRandomTreeNode(currentDepth + 1,
                        newNominalCandidates, minNumericVals, maxNumericVals,
                        treeRand);
            }
        } else {
            int numericIndex = chosenAtt - nominalAttCandidates.size();
            node.splitAttIndex = this.numNominalsOption
                    + numericIndex;
            double minVal = minNumericVals[numericIndex];
            double maxVal = maxNumericVals[numericIndex];
            node.splitAttValue = ((maxVal - minVal) * treeRand.nextDouble())
                    + minVal;
            node.children = new Node[2];
            double[] newMaxVals = maxNumericVals.clone();
            newMaxVals[numericIndex] = node.splitAttValue;
            node.children[0] = generateRandomTreeNode(currentDepth + 1,
                    nominalAttCandidates, minNumericVals, newMaxVals, treeRand);
            double[] newMinVals = minNumericVals.clone();
            newMinVals[numericIndex] = node.splitAttValue;
            node.children[1] = generateRandomTreeNode(currentDepth + 1,
                    nominalAttCandidates, newMinVals, maxNumericVals, treeRand);
        }
        return node;
    }


    public void prepareForUse() {

        //generate instance header.
        generateHeader();


        //generate a random decision tree
        generateRandomTree();


        //TODO: ???
        restart();
    }

    private void restart() {
        this.instanceRandom = new Random(this.instanceRandomSeedOption);

    }


}
